[{"uri":"https://compositionalit.github.io/farmer/api-overview/template-generation/","title":"Generating templates","tags":[],"description":"","content":"Farmer supports several ways to \u0026ldquo;output\u0026rdquo; ARM templates.\nGenerating JSON as a string You can generate an ARM template as a plain string:\nlet json = deployment.Template |\u0026gt; Writer.toJson // prints out the JSON  printfn \u0026#34;%s\u0026#34; json Writing to a file You can write out the ARM template directly to a file, from which you can then deploy to Azure using whichever mechanism you already use e.g. Azure CLI, Powershell, REST API etc.\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myTemplate\u0026#34; Notice how we use F#\u0026lsquo;s pipe operator to \u0026ldquo;pipe\u0026rdquo; data from the template configuration into json before writing to a file.\nIntegrated deployment to Azure You can also turn over deployment of the template directly to Farmer. In this case, it orchestrates commands to the Azure CLI as required.\nlet response = deployment |\u0026gt; Deploy.tryExecute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters match response with | Ok outputs -\u0026gt; printfn \u0026#34;Success! Outputs: %A\u0026#34; outputs | Error error -\u0026gt; printfn \u0026#34;Failed! %s\u0026#34; error As you can see, the response of calling tryExecute is a Result object which is either Ok, in which case any outputs returned from the template are made available as a Map\u0026lt;string, string\u0026gt;, or an Error, which is the error returned by the Azure CLI. Alternatively, you can call execute which will throw an exception rather than return a Result.\n You must have the Azure CLI installed on your machine in order for Farmer to perform deployments for you.\n Authenticating to Azure Azure CLI stores a login token on your machine, and Farmer will check for this. If you aren\u0026rsquo;t logged in, Farmer will automatically start the interactive Azure CLI login process for you.\nFor automated deployments e.g. continuous deployment or through scripts etc., you\u0026rsquo;ll want to use an unattended deployment mode. Some CI systems such as Azure Devops come with an pre-authenticated Azure CLI terminal from which you can run an application that uses Farmer. Alternatively, you can create a service principal, and supply them to the Deploy.authenticate function before calling Deploy.execute.\nYou should use a secure mechanism for storing and supplying the credentials to Farmer. Do not commit them into source control!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/app-insights/","title":"App Insights","tags":[],"description":"","content":"Overview The App Insights builder is used to create Application Insights accounts. Use this if you need a standalone AI instance; if you need one for a web app, the web app will create one by default and configure the application settings automatically.\n Application Insights (Microsoft.Insights/components)  Builder Keywords    Keyword Purpose     name Sets the name of the App Insights instance.    Configuration Members    Member Purpose     InstrumentationKey Gets the ARM expression path to the instrumentation key of this App Insights instance.    Example open Farmer open Farmer.Builders let ai = appInsights { name \u0026#34;myAI\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/arm/","title":"ARM Deployment","tags":[],"description":"","content":"Overview The ARM deployment builder is always the top-level element of your deployment. It contains the manifest of all Farmer resources that you create.\nBuilder Keywords    Keyword Purpose     location Sets the default location of all resources.   add_resource Adds a resource to the template.   add_resources Adds a collection of resources to the template.   output Creates an output value that will be returned by the ARM template. Since Farmer does not require variables, and the only parameters supported are secure strings, these will typically be an ARM expressions that are generated at deployment-time, such as the publishing password of a web app or the fully-qualified domain name of a SQL instance etc.    Example let deployment = arm { // All resources will share this location  location Locations.NorthEurope // Assume myStorageAccount and myWebApp have been defined...  add_resource myStorageAccount add_resource myWebApp output \u0026#34;webAppName\u0026#34; myWebApp.Name output \u0026#34;webAppPassword\u0026#34; myWebApp.PublishingPassword } "},{"uri":"https://compositionalit.github.io/farmer/about/","title":"About","tags":[],"description":"","content":"About Farmer Farmer is an open source, free to use .NET domain-specific-language (DSL) for rapidly generating non-complex Azure Resource Manager (ARM) templates.\nFor those of you working with Azure today, you may already be aware that one of the most useful features is the ability to generate entire infrastructure architectures as code via ARM Template files. These templates contain a declarative model that allows repeatable deployments and idempotent releases (among other things).\nWhat\u0026rsquo;s wrong with ARM? Unfortunately, ARM templates have some limitations caused by the fact that they must be authored in a verbose JSON dialect:\n They provide very limited type checking and support, which makes creating discovery and creation of template features difficult. Templates need a lot of boilerplate to be created for even relatively simple and common resources. It requires \u0026ldquo;embedded\u0026rdquo;, difficult-to-maintain stringly-typed code in order to achieve what might be trivial in a \u0026ldquo;proper\u0026rdquo; programming language, such as references, variables and parameters - or writing elements such as loops. The documentation for ARM templates is not always kept up-to-date, so understanding and learning how to properly use them can involve a lot of searching and trial-and-error.  In other words, whilst working with ARM templates that have already been created is relatively straightforward, the authoring of the templates themselves is time-consuming and error-prone.\nWhilst there have been some recent improvements to ARM - including tooling improvements in VS Code through an extension - we think that we can do much better than relying on tooling for a specific IDE, which means using something different than JSON when directly authoring ARM templates.\nWhat does Farmer do to fix this? Farmer templates are simple .NET Core applications which reference the Farmer NuGet package. This package contains a set of types that model Azure resources in a strongly-typed and succinct fashion, as well as functionality to create ARM templates from this model - and even deploy directly to Azure.\nWhat can I use Farmer for? Farmer currently has support for a large number of common resources including web apps, sql and storage, with more being added over time.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-1/","title":"Your first Farmer template","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll:\n create a web application with a fully-configured Application Insights instance create an ARM deployment object and assign the web app to it generate an ARM template  Creating a Farmer app Create an F# console application using the .NET SDK and add the Farmer package in an empty directory:\ndotnet new console -lang F# dotnet add package Farmer  Farmer also has a .NET template to get started even more quickly!\n Defining a Farmer web application Open Program.fs and delete all the contents.\n In Farmer, resources are defined using special code blocks that look somewhat json-esque, known as a \u0026ldquo;builder\u0026rdquo;. In these builders you can quickly and easily configure a resource using special keywords, but unlike json you also have edit-time safety.\n Create a Farmer web application using the webApp { } builder:\nopen Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } Create an ARM template deployment object, before setting the location for the overall resource group and adding the web app into it.\nlet deployment = arm { location Location.NorthEurope add_resource myWebApp } Generating the ARM template Now you need to generate the ARM template from the deployment object to an ARM json file.\nAdd the following code:\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; Run the application; you should notice that the file myFirstTemplate.json has been created.\nThe generated ARM template contains the following resources:\n A web application A server farm An application insights instance  The resources will be correctly configured with the appropriate dependencies set.\nThe full application open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } let deployment = arm { location Location.NorthEurope add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/","title":"Resources","tags":[],"description":"","content":"Resources Farmer currently has support for the most popular resources in Azure, such as Storage, App Service and Functions. You can find out more about each resource in detail in the menu.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-2/","title":"Working with multiple resources","tags":[],"description":"","content":"Introduction In this quickstart, you\u0026rsquo;ll expand on the deployment authored in the previous quickstart as follows:\n add an Azure storage account add an application setting to the web app that references the storage account\u0026rsquo;s key set a dependency between the two resources  Creating a storage account Create a storage account by using the storageAccount builder.\nlet myStorage = storageAccount { name \u0026#34;yourfirststorage\u0026#34; }  Azure Storage Account names must be globally unique and between 3-24 alphanumeric lower-case characters:\n Referencing the storage account in the web app In this section, we will add an app setting to the web app and set the value to the storage account\u0026rsquo;s connection string.\n In F#, you need to define a value before you reference it, so make sure that you define the storage account above the web app.\n Add the storage account\u0026rsquo;s connection key to the webapp as an app setting.\nlet myWebApp = webApp { ... setting \u0026#34;STORAGE_CONNECTION\u0026#34; myStorage.Key }  Settings can be strings or (as in this case) an ARM expression, which is evaluated at deployment time.\n Setting a dependency on the storage account In ARM templates, you need to explicitly set up dependencies between resources that refer to one another; this is still required in Farmer. This tells Azure to create the storage account before it creates the web app.\nlet myWebApp = webApp { ... depends_on myStorage } Adding the storage account to the deployment Add the storage account to the deployment using the same add_resource keyword as you did with myWebApp.\nAnalysing the ARM template Run the application; you should notice that the template now contains a storage account. Also observe the dependency that has been created:\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2016-08-01\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;yourfirststorage\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Web/sites\u0026#34; } ] } Also observe the application setting that has been created:\n{ \u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=yourfirststorage;AccountKey=\u0026#39;, listKeys(\u0026#39;yourfirststorage\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } ] } The full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key depends_on myStorageAccount.Name } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/","title":"Quickstarts","tags":[],"description":"","content":"This section contains quickstarts to performing common tasks.\n Creating your first Farmer template Creating multiple resources Deploying to Azure The Farmer .NET Template  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-group/","title":"Container Group","tags":[],"description":"","content":"Overview The Container Group builder is used to create Azure Container Group instances.\n Container Group (Microsoft.ContainerInstance/containerGroups)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Group instance.   image Sets the container image.   ports Sets the ports the container exposes.   cpu_cores Sets the maximum CPU cores the container may use.   memory Sets the maximum gigabytes of memory the container may use.   group_name Sets the name of the container group.   link_to_container_group Links this container to an already-created container group.   os_type Sets the OS type (default Linux).   restart_policy Sets the restart policy (default Always)   ip_address Sets the IP addresss (default Public).   add_tcp_port Adds a TCP port to be externally accessible.   add_udp_port Adds a UDP port to be externally accessible.    Example open Farmer open Farmer.Builders let nginx = container { group_name \u0026#34;appWithHttpFrontend\u0026#34; os_type Linux add_tcp_port 80us add_tcp_port 443us restart_policy ContainerGroup.RestartPolicy.Always name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:1.17.6-alpine\u0026#34; ports [ 80us; 443us ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-registry/","title":"Container Registry","tags":[],"description":"","content":"Overview The Container Registry builder is used to create Azure Container Registry (ACR) instances.\n Container Registry (Microsoft.ContainerRegistry/registries)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Registry instance.   sku Sets the SKU of the instance. Defaults to Basic.   enable_admin_user The value that indicates whether the admin user is enabled.    Example open Farmer open Farmer.Builders let myRegistry = containerRegistry { name \u0026#34;myRegistry\u0026#34; sku ContainerRegistry.Basic enable_admin_user } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cognitive-services/","title":"Cognitive Services","tags":[],"description":"","content":"Overview The Cognitive Services builder is used to create Azure Cognitive Services instances.\n Cognitive Services (Microsoft.CognitiveServices/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to F0 (free).   api Specifies the API to use for the service instance. Defaults to AllInOne.    Example open Farmer open Farmer.Builders let translator = cognitiveServices { name \u0026#34;mytranslator\u0026#34; sku CognitiveServices.F0 api CognitiveServices.AnomalyDetector } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/parameters/","title":"Parameters and Variables","tags":[],"description":"","content":"ARM templates support the idea both of parameterisation of templates and of the use of variables within a template for e.g. placeholders and re-using values.\nFarmer, by design, has only limited support for parameters and no support for variables. We don\u0026rsquo;t plan on adding rich support for either of these for the following reasons:\n We want to keep the Farmer codebase simple for maintainers We want to keep the Farmer API simple for users We want to keep the generated ARM templates as readable as possible We feel that instead of trying to embed conditional logic and program flow directly inside ARM templates in JSON, if you wish to parameterise your template that you should use a real programming language to do that: in this case, F#.  You can read more on this issue here\nSecure Parameters Farmer does support securestring parameters for e.g. SQL and Virtual Machine passwords - these are automatically generated based on the contents of the template rather than explicitly by yourself.\nFor example, assume the following Farmer SQL resource:\nlet db = sql { server_name \u0026#34;myserver\u0026#34; db_name \u0026#34;mydatabase\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } This will generate an ARM template which looks as follows (irrelevant content is elided for clarity):\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-myserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2014-04-01-preview\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;myserver\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;administratorLogin\u0026#34;: \u0026#34;mradmin\u0026#34;, \u0026#34;administratorLoginPassword\u0026#34;: \u0026#34;[parameters(\u0026#39;password-for-myserver\u0026#39;)]\u0026#34;, }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Sql/servers\u0026#34; } ] } Working with variables ARM templates allow you to declare variables inside a template to reuse a value across a template. ARM templates also allow the use of a custom set of a commands which are embedded within strings to generate program logic, using expressions which contain template functions. For example, to concatenate a string inside a ARM template made up of two variables and put into a third variable, you might use something like the following:\n{ \u0026#34;variables\u0026#34;: { \u0026#34;first\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;second\u0026#34;: \u0026#34;World\u0026#34;, \u0026#34;serverName\u0026#34;: \u0026#34;[concat(variables(\u0026#39;first\u0026#39;), \u0026#39; \u0026#39;, variables(\u0026#39;second\u0026#39;), \u0026#39;!\u0026#39;)]\u0026#34; } } In F#, you have access to the full power of .NET, rather than a limited set of weakly-typed functions:\nlet first = \u0026#34;Hello\u0026#34; let second = \u0026#34;World\u0026#34; let serverName = first + \u0026#34; \u0026#34; + second + \u0026#34;!\u0026#34; let dbName = sprintf \u0026#34;%s %s!\u0026#34; first second let db = sql { server_name serverName db_name dbName admin_username \u0026#34;mradmin\u0026#34; } Rapidly creating multiple resources You can also use F# list comprehensions to rapidly create several resources of the same type:\n// Create five SQL servers and databases let myDatabases = [ for i in 1 .. 5 -\u0026gt; sql { server_name (sprintf \u0026#34;server%d\u0026#34; i) db_name (sprintf \u0026#34;database%d\u0026#34; i) admin_username \u0026#34;mradmin\u0026#34; } ] // Add all five databases to the deployment let deployment = arm { location Location.NorthEurope add_resources myDatabases } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/","title":"API Overview","tags":[],"description":"","content":"API aims The key guiding principles of the Farmer API are (in order):\n Simplicity: Make it as easy as possible to do the most common tasks. Type safety: Where possible, use F#\u0026lsquo;s type system to make it impossible to create invalid templates. Flexibility: Provide users with the ability to override the defaults where needed.  Farmer Resources Farmer works on a simple, consistent process:\n You create Farmer resources, such as Storage Accounts and Web Apps. Each Farmer resource can represent one or many ARM resources. For example, a Farmer webApp resource represents both the Microsoft.Web/sites and Microsoft.Web/serverfarms resources. In addition, it optionally also provides simplified access to an Microsoft.Insights/components. You configure each resource using simple, human-readable custom keywords in a strongly-typed environment. You link together resources as required. Once you have created all resources, you bundle them up together into an ARM deployment resource. You then generate (and optionally deploy) an ARM template. The rest of your deployment pipeline stays the same.  The diagram below illustrates how Farmer resources map to ARM ones:\ngraph TD subgraph ARM Template classDef danger fill:orange; C(Microsoft.Web/serverfarms) -. dependency .-F D(Microsoft.Insights/components) -. dependency .-F E(Microsoft.Storage/storageAccounts) -. dependency .-F E -. storage key .- F E -. storage key .- G F(Microsoft.Web/sites) G(blobServices/containers) class C danger class D danger class E danger class F danger class G danger end subgraph Farmer A(webApp)-. depends on .-B B(storageAccount)-. key .-A end  In this example, we create a storage account and web app in Farmer, which maps five different ARM template resources. As you can see, resources in Farmer are declared at a higher level of abstraction than ARM template resources. This makes things much simpler to reason about, and quicker to author.\nAn example Farmer Resource All Farmer resources follow the same approach:\n You define a resource using a special \u0026ldquo;builder\u0026rdquo; that allows the use of custom keywords. This is known as an F# computation expression. Each builder is designed for a specific type of Azure resource e.g. websites, functions, virtual machines etc., and each has defaults set for the most common scenario. This resource is validated and converted into a Farmer configuration object, which contains the configuration for that resource including any defaults. This configuration is then added to an overarching Farmer ARM deployment object. The ARM deployment object is converted into an ARM template json file.  graph LR subgraph JSON C(ARM Template) end subgraph .NET A(Farmer Builder)--validation and defaults --B B(Farmer Configuration) --emitted to -- C end  Here\u0026rsquo;s an example web application.\nlet myWebApp = webApp { name \u0026#34;mystorage\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku Sku.B1 always_on app_insights_off worker_size WorkerSize.Medium number_of_workers 3 run_from_package }  The webApp { } builder defines the start and end of the definition of the web application. Within this builder, you use custom keywords to configure the web app, such as name and setting. Some keywords take arguments, but others e.g. always_on are simple declarative markers.   You can view details of all farmer resources in the resource guide.\n Putting it all together The diagram above can be shown in code as follows:\n/// An Azure Storage account with a container. let storage = storageAccount { name \u0026#34;astorageaccount\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } /// An Azure App Service with built-in App Insights. let app = webApp { name \u0026#34;awebapp\u0026#34; setting \u0026#34;storageKey\u0026#34; storage.Key // pull in the storage key to an app setting  depends_on storage // state that this web app depends on the storage account } /// An ARM deployment with both of the above resources attached let deployment = arm { location Location.NorthEurope add_resource storage add_resource app } // Write the ARM template out to myTemplate.json let filename = deployment.Template |\u0026gt; Writer.toJson |\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cosmosdb/","title":"Cosmos DB","tags":[],"description":"","content":"Overview The CosmosDb package containers two builders, used to create databases and containers.\n CosmosDB Account (Microsoft.DocumentDb/databaseAccounts) CosmosDB SQL (\u0026quot;Microsoft.DocumentDB/databaseAccounts/sqlDatabases) CosmosDB SQL Container (Microsoft.DocumentDb/databaseAccounts/sqlDatabases/containers)   There is currently only support for document databases (the so-called \u0026ldquo;SQL API\u0026rdquo;), with support for Gremlin, Table and Cassandra data models planned.\n Cosmos DB Builder The CosmosDB builder abstracts the idea of account and database into one. If you wish to \u0026ldquo;re-use\u0026rdquo; an already-created Cosmos DB account, use link_to_account keyword - no account will be created and the database will be attached to the existing one.\n   Applies To Keyword Purpose     Database name Sets the name of the database.   Database link_to_account Instructs Farmer to link this database to an existing Cosmos DB account rather than creating a new one.   Database throughput Sets the throughput of the account.   Database add_containers Adds a list of containers to the database.   Account account_name Sets the name of the CosmosDB account.   Account api (not yet implemented) Sets the API and data model to use \u0026ndash; currently defaults to \u0026ldquo;Core (SQL)\u0026quot;.   Account enable_public_network_access Enables public network access for the account.   Account disable_public_network_access Disables public network access for the account.   Account consistency_policy Sets the consistency policy of the database.   Account failover_policy Sets the failover policy of the database.   Account free_tier Registers this server with the free pricing tier, if supported and allowed by Azure.    Cosmos Container Builder The container builder allows you to create and configure a specific container that is attached to a cosmos database.\n   Keyword Purpose     name Sets the name of the container.   partition_key Sets the partition key of the container.   add_index Adds an index to the container.   exclude_path Excludes a path from the container index.    Example open Farmer open Farmer.Builders let myCosmosDb = cosmosDb { name \u0026#34;isaacsappdb\u0026#34; account_name \u0026#34;isaacscosmosdb\u0026#34; throughput 400 failover_policy CosmosDb.NoFailover consistency_policy (CosmosDb.BoundedStaleness(500, 1000)) add_containers [ cosmosContainer { name \u0026#34;myContainer\u0026#34; partition_key [ \u0026#34;/id\u0026#34; ] CosmosDb.Hash add_index \u0026#34;/path\u0026#34; [ CosmosDb.Number, CosmosDb.Hash ] exclude_path \u0026#34;/excluded/*\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-3/","title":"Deploying to Azure","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll update the application to deploy the generated ARM template to Azure directly from Farmer.\n Farmer generates normal ARM templates. You use all of the standard mechanisms for deploying ARM templates such as through the portal, Powershell, .NET or Azure CLI etc. This tutorial shows you a simple way to deploy templates from your development machine directly from within F#.\n Install the Azure CLI If you haven\u0026rsquo;t done so already, install the Azure CLI on your machine.\nDeploy the template As Farmer emits standard ARM templates, you can use all the standard ARM template deployment tools at your disposal - whether that\u0026rsquo;s Visual Studio, Powershell, or the Azure CLI. In our case, we can also use Farmer\u0026rsquo;s API which wraps around the Azure CLI.\nModify the application you created at the end of quickstart #2 so that instead of writing the template to a file, we deploy it directly:\ndeployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters  Note that the Web Application and Storage Account names should be globally unique; they must be unique across Azure i.e. someone else can\u0026rsquo;t have another web app or storage account with the same name!\n Farmer will now create the ARM template, and also generate a batch / shell script which calls the Azure CLI. You\u0026rsquo;ll be prompted to login to Azure by the CLI, after which point it will create the named resource group in the location specified in the arm { } builder.\nWait until the process is completed and log into the Azure Portal. Navigate to the newly-created resource group and inspect the overview record list e.g.\nCongratulations - you\u0026rsquo;ve now created and deployed an ARM template entirely from F#!\nThe full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key depends_on myStorageAccount.Name } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters "},{"uri":"https://compositionalit.github.io/farmer/api-overview/expressions/","title":"ARM Expressions","tags":[],"description":"","content":"ARM template expressions are a way of safely storing string values which contain expressions that are evaluated at deployment time by the Azure. ARM expressions can also contain a set of predefined functions supported by the ARM runtime.\nFarmer understands how to use ARM expressions and provides functionality to correctly wrap and unwrap them as raw strings into a JSON template.\n For manipulation of literal values that are known on the client, you will not need to use ARM expressions. To manipulate such values, you can use standard F# and .NET capabilities.\n How do I use ARM expressions? Many Farmer builders contain pre-defined ARM expression that can be used for common tasks, such as passing a connection string from a storage account as a KeyVault secret, or a web application setting.\nAs an example, a Storage Account config contains a Key member that you can supply this to a web app as a setting:\nlet storageConfig = storageAccount { name \u0026#34;myStorageAccount\u0026#34; } let webAppConfig = webApp { name \u0026#34;myWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; storageConfig.Key } This will be written to the ARM template file as follows:\n\u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=myStorageAccount;AccountKey=\u0026#39;, listKeys(\u0026#39;myStorageAccount\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } Using ARM expressions means that you can deploy an application which is automatically configured at deployment time. This means that you never need to store an application secret such as a storage account key in source control, or even e.g. as a secret variable in your build / deployment process.\nCreating your own ARM Expressions Farmer ARM expressions are in reality just wrapped strings, and are easy to create. For example, the code to create the Key property above is similar to this:\nlet buildKey (name : string) : ArmExpression = // Create the raw string of the expression  let rawValue : string = sprintf \u0026#34;concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=\u0026#39;, listKeys(\u0026#39;%s\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)\u0026#34; name name // Wrap it in an ARM Expression and return it  ArmExpression rawValue Notice that you do not wrap the expression in square brackets [ ]; Farmer will do this when writing out the ARM template.\n"},{"uri":"https://compositionalit.github.io/farmer/deployment-guidance/","title":"Deployment Guidance","tags":[],"description":"","content":"You can deploy Farmer templates in a number of ways, depending on how you would prefer to work with ARM templates and tooling.\nOption 1: \u0026ldquo;ARM templates are just a means to an end to me\u0026rdquo; If you don\u0026rsquo;t use ARM templates today, or don\u0026rsquo;t need to edit them directly, you can opt to do away with them completely. You\u0026rsquo;ll create Farmer applications which use a simple F# SDK to interact with Azure; Farmer will create ARM templates in the background for you transparently, so you\u0026rsquo;ll never see or interact with them.\nIn such a case, you can opt to deploy directly through Farmer. This mode provides an F# wrapper around the Azure CLI which captures your credentials during the deployment process.\nIf you\u0026rsquo;re looking to stay within F# and e.g. respond to outcomes from the deployment such as using deployment outputs, this is an excellent option because Farmer is just a dotnet application and the deployment call is a simple function call.\nAnother benefit of this is because Farmer is a simple .NET Standard library, you can use it natively within .NET build tools such as FAKE or CAKE.\nCombined Resource and Application Deployment Farmer can also optionally do more for you by handling the entire deployment process, including deployment of your application artifacts.\ngraph LR subgraph Azure Resource Group D(Azure App Service) end subgraph JSON C(ARM Template) -- REST API or Azure CLI -- D end subgraph .NET A(Farmer)-- resources emitted to -- C A -. your application deployed via ZIP Deploy.- D end  Watch this short video to see more!\n  Option 2: \u0026ldquo;I already have an ARM deployment strategy\u0026rdquo; If you already use ARM templates, you\u0026rsquo;ll probably already have a strategy for working with templates and deploying them to Azure, such as PowerShell, the Azure CLI or a build system such as Azure DevOps or Octopus Deploy. In such a case, you may want to use Farmer to generate, but not deploy, your ARM templates.\nOption 3: \u0026ldquo;I want to hand-craft my ARM templates\u0026rdquo; If you want to retain fine-grained control over ARM templates, you can use Farmer to create a one-off task to rapidly generate an ARM template which you then take ownership of. In this case, Farmer itself won\u0026rsquo;t be a part of your build / deploy chain, which will remain the same as today - you\u0026rsquo;ll use Farmer just as an edit-time task to create an ARM template itself which you will then manually modify.\nThe choice is yours.\nHow do I create a Service Principal? If you\u0026rsquo;re trying to deploy to Azure in an automated fashion, you may need to create a Service Principal account that has permissions in Azure to deploy ARM templates on your behalf.\nThe Azure CLI provides a simple way to create one using the az ad sp command:\naz ad sp create-for-rbac --name farmer-deploy This will provide output similar to the following:\n{ \u0026#34;appId\u0026#34;: \u0026#34;1181c21b-78f3-42b3-a26d-03ba75c7b674\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;farmer-deploy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;http://farmer-deploy\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;4aa3b120-f2b2-4ea9-941b-5891fef0ef11\u0026#34;, \u0026#34;tenant\u0026#34;: \u0026#34;aa7f7453-15af-4ab0-5d41-aeb4a25293bc\u0026#34; } The mapping from these fields to the credentials used in Farmer\u0026rsquo;s authenticate function are:\n   Azure CLI Farmer     appId appId   password secret   tenant tenantId    You should store these credentials in a secure store, such as your CI/CD service or e.g. Azure KeyVault and should avoid committing them into source control.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/template/","title":"The Farmer .NET Template","tags":[],"description":"","content":"Farmer comes with a .NET template that makes getting started easy.\nCreating a basic Farmer app The easiest way to create a Farmer app is to use the Farmer .NET Template.\ndotnet new -i Farmer.Template dotnet new Farmer  You only have to install the template once on your machine!\n This creates a new dotnet application solution and project that looks by default as follows:\nopen Farmer open Farmer.Builders let deployment = arm { location Location.NorthEurope } printf \u0026#34;Generating ARM template...\u0026#34; deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; printfn \u0026#34;all done! Template written to output.json\u0026#34; From here, you can add resources in the normal manner.\nBasic configuration options You can configure the template using the following optional arguments.\nARM Template filename The name of the ARM template JSON file e.g. --armTemplate myTemplate\nLocation The location to create resources in e.g. --location WestUS\nDeploy Configuration You can also configure the Farmer template to deploy to Azure out of the box using the --ci option. This has two modes of operation:\nAzure DevOps deployment This comes with a ready-made devops YAML file designed for simple CI/CD, using Farmer to generate ARM templates and Azdo to deploy using its own ARM Template deployment process. You should supply the following arguments:\n \u0026ndash;ci devops: Tells the template to create a Farmer app for use with Azdo. \u0026ndash;azureSubscription: Set the full name of the Azure Subscription that has been already configured in Azdo with permission to deploy templates to Azure. \u0026ndash;resourceGroup: Set the name of the resource group that you wish to deploy to.  Direct deployment If you prefer a deployment process that is not coupled to Azure Devops, you can create a service principle in Azure and use the generated credentials in Farmer. Farmer will use its own wrapper around the Azure REST API to deploy to Azure, reporting progress to the console. You should supply the following arguments:\n \u0026ndash;ci direct: Tells the template to create a Farmer app for use with a service principle. The generated application expects to receive credentials via environment variables, but you can of course change this as required.  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/eventhub/","title":"Event Hub","tags":[],"description":"","content":"Overview The Event Hub builder creates event hub namespaces, event hubs, consumer groups and authorization rules in a single builder.\n Event Hub Namespace (Microsoft.EventHub/namespaces) Event Hub (Microsoft.EventHub/namespaces/eventhubs) Consumer Group (Microsoft.EventHub/namespaces/eventhubs/consumergroups) Authorization Rule (Microsoft.EventHub/namespaces/eventhubs/AuthorizationRules\u0026quot;)   The Event Hub builder works in a similar fashion to the web app builder in that it automatically creates the host (in this case, the event hub namespace) when creating the event hub. If you wish to create multiple hubs in the same namespace, configure the namespace-level properties in the first event hub; subsequent event hubs should link to the namespace of the hub created by the first hub.\n Builder Keywords    Applies To Keyword Purpose     Namespace namespace_name Sets the name of the event hub namespace, if you are creating the namespace along with the hub.   Namespace sku Sets the SKU of the event hub namespace.   Namespace capacity Sets the capacity of the event hub namespace (see here for more details)   Namespace enable_zone_redundant Enables zone redundancy on the event hub namespace.   Namespace enable_auto_inflate Enables auto inflate throughput; you must supply the maximum throughput level.   Namespace disable_auto_inflate Disables auto inflate throughput.   Namespace disable_kafka Disables Kafka support.   Event Hub name Sets the name of the event hub.   Event Hub message_retention_days Sets the number of days to retain messages for on the event hub.   Event Hub partitions Sets the number of partitions on the event hub.   Event Hub add_consumer_group Creates a consumer group for the event hub.   Event Hub add_authorization_rule Adds a named authorization rule on the event hub.   Event Hub link_to_namespace Sets the name of an existing or already-defined event hub namespace that this event hub should link to.    Configuration Members    Member Purpose     DefaultKey Gets an ARM expression for the root namespace key of the Event Hub namespace.   GetKey Gets an ARM expression for a named key on this event hub.    Example open Farmer open Farmer.Builders let primaryHub = eventHub { namespace_name \u0026#34;allmyevents\u0026#34; sku EventHub.Standard disable_kafka enable_zone_redundant enable_auto_inflate 3 add_authorization_rule \u0026#34;FirstRule\u0026#34; [ EventHub.Listen; EventHub.Send ] add_authorization_rule \u0026#34;SecondRule\u0026#34; AllAuthorizationRights name \u0026#34;first-hub\u0026#34; partitions 2 message_retention_days 3 add_consumer_group \u0026#34;myGroup\u0026#34; } let secondHub = eventHub { name \u0026#34;second-hub\u0026#34; link_to_namespace \u0026#34;allmyevents\u0026#34; partitions 1 message_retention_days 1 } "},{"uri":"https://compositionalit.github.io/farmer/faq/","title":"FAQs","tags":[],"description":"","content":"How can I help? Try out Farmer and see what you think.\n Create as many issues as you can for both bugs, discussions and features Create suggestions for features and the most important elements you would like to see added  I have an Azure subscription, but I\u0026rsquo;m not an expert. I like the look of this - how do I \u0026ldquo;use\u0026rdquo; it?  Create an ARM template using the Farmer sample app. Follow the steps here to deploy the generated template into Azure. Log any issues or ideas that you find here.  How do I get Farmer to work from a continuous deployment (CD) process?  Look at some of the alternative strategies outlined here. Read up on ARM deployment strategies e.g. Azure Devops have guides here.  We are looking at creating templating options to simplify this process further in the future.\nI don\u0026rsquo;t know F#. Would you consider writing a C# version of this? I\u0026rsquo;m afraid not. F# isn\u0026rsquo;t hard to learn (especially for simple DSLs such as this), and you can easily integrate F# applications as part of a dotnet solution, since F# is a first-class citizen of the dotnet core ecosystem.\nAre you trying to replace ARM templates? No, we\u0026rsquo;re not. Farmer generates ARM templates that can be used just as normal; Farmer can be used simply to make the process of getting started much simpler, or incorporated into your build pipeline as a way to avoid managing difficult-to-manage ARM templates and instead use them as the final part of your build / release pipeline.\nAre you trying to compete with Pulumi? No, we\u0026rsquo;re not. Farmer has (at least currently) a specific goal in mind, which is to lower the barrier to entry for creating and working with ARM templates that are non-complex. We\u0026rsquo;re not looking to create a cross-platform DSL to also support things like Terraform etc. or provide a stateful service store that Pulumi offers. Instead, Farmer is a simple way to continue to use ARM templates today but benefit from a more rapid authoring and maintenance process.\nThere\u0026rsquo;s no support for variables or parameters! Farmer intentionally has limited support for ARM parameters and variables. Read here to find out the alternatives.\nThe resource I need isn\u0026rsquo;t included! Create an issue on our github repository, ideally with a sample ARM template and a link to the official Microsoft documentation on the resource. We can\u0026rsquo;t promise we\u0026rsquo;ll look at it immediately, but raising the issue is an important first step to getting more resources supported.\nBut our organisation really needs that resource enhancement today! Drop us an email explaining what you need; we\u0026rsquo;re happy to discuss a commercial support arrangement to provide you with features that you need in a more timely fashion.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/functions/","title":"Functions","tags":[],"description":"","content":"Overview The Functions builder is used to create Azure Functions accounts. It abstracts the App Host and Service Plan into the same component, and will also create and configure a linked App Insights resource. In addition, it will automatically create a backing storage account required by the functions runtime.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Storage Accounts (Microsoft.Storage/storageAccounts)  Builder Keywords    Keyword Purpose     name Sets the name of the functions instance.   service_plan_name Sets the name of the service plan hosting the function instance.   link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   link_to_storage_account Do not create an automatic storage account; instead, link to a storage account that is created outside of this Functions instance.   https_only Disables http for this functions app so that only HTTPS is used.   app_insights_auto_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   use_runtime Sets the runtime of the Functions host.   use_extension_version Sets the extension version of the functions host.   operating_system Sets the operating system of the Functions host.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   depends_on Sets a dependency for the web app.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this functions app.   StorageAccountKey Gets the ARM expression path to the storage account key of this functions app.   AppInsightsKey Gets the ARM expression path to the app insights key of this functions app, if it exists.   DefaultKey Gets the ARM expression path for the default key of this functions app.   MasterKey Gets the ARM expression path for the master key of this functions app.    Example open Farmer open Farmer.Builders let myFunctions = functions { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; app_insights_off }```"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/iot-hub/","title":"IOT Hub","tags":[],"description":"","content":"Overview The IOT Hub builder creates IOT Hub and linked Provision Services.\n IOT Hubs (Microsoft.Devices/IotHubs) Provisioning Services (Microsoft.Devices/provisioningServices)  Builder Keywords    Keyword Purpose     name Specifies the name of the IOT Hub   sku Sets the SKU of the IOT Hub   capacity Sets the name of the capacity for the IOT Hub instance   partition_count Sets the name of the SKU/Tier for the IOT Hub instance   retention_days Sets the name of the SKU/Tier for the IOT Hub instance   enable_device_provisioning Sets the name of the SKU/Tier for the IOT Hub instance    Configuration Members    Member Purpose     GetKey Returns an ARM expression to retrieve the IOT Hub key for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.   GetConnectionString Returns an ARM expression to generate an IOT Hub connection string for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let hub = iotHub { name \u0026#34;yourhubname\u0026#34; sku IotHub.B1 capacity 2 partition_count 2 retention_days 3 enable_device_provisioning } let deployment = arm { location Location.NorthEurope add_resource hub output \u0026#34;iot_key\u0026#34; (hub.GetKey IotHub.IotHubOwner) output \u0026#34;iot_connection\u0026#34; (hub.GetConnectionString IotHub.RegistryReadWrite) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/keyvault/","title":"Key Vault","tags":[],"description":"","content":"Overview The KeyVault package contains three builders, for the different components used by KeyVault: One for access policies, one for secrets, and one for the overall keyvault container.\n KeyVault (Microsoft.KeyVault/vaults) Secrets (Microsoft.KeyVault/vaults/secrets)  Secret Builder The secret builder allows you to store secrets into key vault. Values for a secret are passed by Secure String parameters.\n   Keyword Purpose     name Sets the name of the secret.   value Sets the name of the secure string parameter that will contain the value of the secret.   content_type Sets the content type of the secret.   enable_secret Enables the secret.   disable_secret Disables the secret.   activation_date Sets the activation date of the secret.   expiration_date Sets the expiration date of the secret.   depends_on Provides dependencies of the key vault.    Access Policy Builder The Access Policy builder allows you to create access policies for key vault.\n   Keyword Purpose     object_id Sets the Object ID of the permission set.   application_id Sets the Application ID of the permission set.   key_permissions Sets the Key permissions of the permission set.   storage_permissions Sets the Storage permissions of the permission set.   secret_permissions Sets the Secret permissions of the permission set.   certificate_permissions Sets the Certificate permissions of the permission set.    Key Vault Builder The Key Vault builder contains access policies, secrets, and configuration information to create a full key vault account.\n   Keyword Purpose     name Sets the name of the vault.   sku Sets the sku of the vault.   tenant_id Sets the Tenant ID of the vault.   enable_vm_access Allows VM access to the vault.   disable_vm_access Disallows VM access to the vault.   enable_resource_manager_access Allows Resource Manager access to the vault.   disable_resource_manager_access Disallows Resource Manager access to the vault.   enable_disk_encryption_access Allows Azure Disk Encyption service access to the vault.   disable_disk_encryption_access Disallows Azure Disk Encyption service access to the vault.   enable_soft_delete Enables VM access to the vault.   enable_soft_delete_with_purge_protection Disables VM access to the vault.   uri Sets the URI of the vault.   enable_recovery_mode Sets the Creation Mode to Recovery.   disable_recovery_mode Sets the Creation Mode to Default.   add_access_policy Adds an access policy to the vault.   enable_azure_services_bypass Allows Azure traffic can bypass network rules.   disable_azure_services_bypass Disallows Azure traffic can bypass network rules.   allow_default_traffic Allow traffic if no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   deny_default_traffic Deny traffic when no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   add_ip_rule Adds an IP address rule. This can be an IPv4 address range in CIDR notation, such as \u0026lsquo;124.56.78.91\u0026rsquo; (simple IP address) or \u0026lsquo;124.56.78.0/24\u0026rsquo; (all addresses that start with 124.56.78).   add_vnet_rule Adds a virtual network rule. This is the full resource id of a vnet subnet, such as \u0026lsquo;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026rsquo;.   add_secret Adds a secret to the vault. This can either be a \u0026ldquo;full\u0026rdquo; secret config created using the Secret Builder or a string literal value which represents the parameter name.    Example open Farmer open Farmer.Builders open System let policy = accessPolicy { object_id Guid.Empty application_id Guid.Empty certificate_permissions [ KeyVault.Certificate.List ] secret_permissions KeyVault.Secret.All key_permissions [ KeyVault.Key.List ] } let complexSecret = secret { name \u0026#34;myComplexSecret\u0026#34; content_type \u0026#34;application/text\u0026#34; enable_secret activation_date (DateTime.Today.AddDays -1.) expiration_date (DateTime.Today.AddDays 1.) } let vault = keyVault { name \u0026#34;MyVault\u0026#34; sku KeyVault.KeyVaultSku.Standard tenant_id Guid.Empty enable_disk_encryption_access enable_resource_manager_access enable_soft_delete_with_purge_protection disable_vm_access enable_recovery_mode add_access_policy policy enable_azure_services_bypass add_ip_rule \u0026#34;127.0.0.1\u0026#34; add_vnet_rule \u0026#34;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026#34; allow_default_traffic add_secret complexSecret add_secret \u0026#34;simpleSecret\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/maps/","title":"Maps","tags":[],"description":"","content":"Overview The Maps builder creates Azure Maps accounts.\n Maps (Microsoft.Maps/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Maps account.   sku Sets the sku of the Azure Maps account.    Example open Farmer open Farmer.Builders let myMaps = maps { name \u0026#34;mymaps\u0026#34; sku Maps.S0 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/redis/","title":"Redis Cache","tags":[],"description":"","content":"Overview The Redis builder creates managed Redis Cache accounts.\n Redis (Microsoft.Cache/redis)  Builder Keywords    Keyword Purpose     name Sets the name of the Redis cache instance.   sku Sets the sku of the Redis cache instance.   capacity Sets the capacity level of the Redis cache instance, should be between 1-6 - see here.   enable_non_ssl_port Enabled access to the cache over the non-SSL port.   setting Allows you to set a Redis-cache specific setting at deployment-time    Configuration Members    Member Purpose     Key Gets an ARM expression for the primary key of the Redis cache instance.    Example open Farmer open Farmer.Builders.Redis let myCache = redis { name \u0026#34;myredis\u0026#34; sku Redis.Standard capacity 1 enable_non_ssl_port setting \u0026#34;maxclients\u0026#34; 256 setting \u0026#34;maxmemory-reserved\u0026#34; 2 setting \u0026#34;maxfragmentationmemory-reserved\u0026#34; 12 setting \u0026#34;maxmemory-delta\u0026#34; 2 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/postgresql/","title":"PostgreSQL","tags":[],"description":"","content":"Overview The PostreSQL builder is used to create Azure Database Service for PostreSQL servers and databases. Every SQL PostgreSQL server you create will automatically create a SecureString parameter for the admin account password. If you wish to create a PostgreSQL database attached to an existing server, use the link_to_server keyword and supply the resource name of the existing server.\n PostgreSQL server (Microsoft.DBforPostgreSQL/servers)  Builder keywords    Applies To Keyword Purpose     Server server_name (string) Sets the name of the SQL server.   Server admin_username (string) Sets the admin username of the server.   Server geo_redundant_backup (bool) Enables/disables geo-redundant backup   Server enable_geo_redundant_backup Enables geo-redundant backup   Server disable_geo_redundant_backup Disables geo-redundant backup   Server storage_autogrow (bool) Enables/disables auto-grow storage   Server enable_storage_autogrow Enables auto-grow storage   Server disable_storage_autogrow Disables auto-grow storage   Server storage_size (int\u0026lt;Gb\u0026gt;) Sets the initial size of the storage available   Server backup_retention (int\u0026lt;Days\u0026gt;) Sets the number of days to keep backups   Server server_version (Version) Selects the PoistgreSQL version of the server   Server capacity (int\u0026lt;VCores\u0026gt;) Sets the number of cores for the server   Server tier (Sku) Sets the service tier of the server   Server db_name (string) Sets the name of a database to create - if not set, no database will be created   Server db_charset (string) Sets the charset of the created database, if db_name is set. Defaults to UTF8   Server db_collation (string) Sets the collation of the created database, if db_name is set. Defaults to English_United States.1252   Server enable_azure_firewall Enables firewall access to all Azure services   Server add_firewall_rule (name:string, start ip:string, end ip:string) Adds a firewall rule to the server    Example open Farmer open Farmer.Builders open Farmer.PostgreSQL let myPostgres = postgreSQL { admin_username \u0026#34;adminallthethings\u0026#34; server_name \u0026#34;aserverformultitudes42\u0026#34; capacity 4\u0026lt;VCores\u0026gt; storage_size 50\u0026lt;Gb\u0026gt; tier GeneralPurpose db_name \u0026#34;things\u0026#34; allow_azure_firewall } let template = arm { location Location.NorthEurope add_resource myPostgres } template |\u0026gt; Writer.quickWrite \u0026#34;postgres-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/search/","title":"Search","tags":[],"description":"","content":"Overview The Search builder creates storage accounts and their associated containers.\n Search (Microsoft.Search/searchServices)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Search instance.   sku Sets the sku of the Azure Search instance.   replicas Sets the replica count of the Azure Search instance.   partitions Sets the number of partitions of the Azure Search instance.    Configuration Members    Member Purpose     AdminKey Gets an ARM expression for the admin key of the search instance.   QueryKey Gets an ARM expression for the query key of the search instance.    Example open Farmer open Farmer.Builders let mySearch = search { name \u0026#34;isaacsSearch\u0026#34; sku Search.Basic } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/service-bus/","title":"Service Bus","tags":[],"description":"","content":"Overview The Service Bus builder creates service bus namespaces and their associated queues.\n Service Bus Namespaces (Microsoft.ServiceBus/namespaces)  Builder Keywords    Applies To Keyword Purpose     Queue name The name of the queue.   Queue lock_duration_minutes The length of time that a lock can be held on a message.   Queue max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Queue duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Queue enable_session Enables session support.   Queue enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Queue enable_partition Enables partition support on the queue.   Queue link_to_namespace Link this queue to an existing namespace instead of creating a new one.   Namespace sku The ServiceBusNamespaceSku e.g. Standard   Namespace namespace_name The name of the namespace that holds the queue.   Namespace depends_on Adds a resource that the service bus depends on.    Configuration Members    Member Purpose     NamespaceDefaultConnectionString Returns an ARM expression to retrieve the Primary Connection String of the service bus.   DefaultSharedAccessPolicyPrimaryKey Returns an ARM expression to retrieve the Primary Key of the service bus.    Example open Farmer open Farmer.Builders let queueA = serviceBus { name \u0026#34;queueA\u0026#34; namespace_name \u0026#34;allQueues\u0026#34; sku ServiceBus.Standard } let queueB = serviceBus { name \u0026#34;queueB\u0026#34; link_to_namespace queueA } let deployment = arm { location Location.NorthEurope add_resource queueA add_resource queueB output \u0026#34;connection-string-queue-a\u0026#34; queueA.NamespaceDefaultConnectionString output \u0026#34;primary-key-queue-b\u0026#34; queueB.DefaultSharedAccessPolicyPrimaryKey } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/sql/","title":"SQL Azure","tags":[],"description":"","content":"Overview The SQL Azure builder is used to called SQL Azure servers and databases. It supports features such as encryption and firewalls. Every SQL Azure server you create will automatically create a SecureString parameter for the admin account password. If you wish to create a SQL Database attached to an existing server, use the link_to_server keyword and supply the resource name of the existing server.\n SQL Azure server (Microsoft.Sql/servers)  Builder Keywords    Applies To Keyword Purpose     Database name Sets the name of the database.   Database sku Sets the sku of the database.   Database collation Sets the collation of the database.   Database use_encryption Enables transparent data encryption of the database.   Database link_to_server Links this database to an existing SQL Azure server instead of creating a new one.   Server server_name Sets the name of the SQL server.   Server add_firewall_rule Adds a custom firewall rule given a name, start and end IP address range.   Server enable_azure_firewall Adds a firewall rule that enables access to other Azure services.   Server admin_username Sets the admin username of the server.    Configuration Members    Member Purpose     FullyQualifiedDomainName Gets the ARM expression path to the FQDN of this SQL instance.   ConnectionString Gets a literal .NET connection string using the administrator username / password. The password will be evaluated based on the contents of the password parameter supplied to the template at deploy time.    Example TBD\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/storage-account/","title":"Storage Account","tags":[],"description":"","content":"Overview The Storage Account builder creates storage accounts and their associated containers.\n Storage Accounts (Microsoft.Storage/storageAccounts) Storage Containers (blobServices/containers)  Builder Keywords    Keyword Purpose     name Specifies the name of the storage account   sku Sets the SKU of the storage account   add_public_container Adds a general-purpose public storage container   add_private_container Adds a general-purpose private storage container   add_blob_container Adds a general-purpose private blob container    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the storage account\u0026rsquo;s primary connection string. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; sku Storage.Premium_LRS add_public_container \u0026#34;myPublicContainer\u0026#34; add_private_container \u0026#34;myPrivateContainer\u0026#34; add_blob_container \u0026#34;myBlobContainer\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-machine/","title":"Virtual Machine","tags":[],"description":"","content":"Overview The Virtual Machine builder creates a fully configured virtual machine and all its required child resources.\n Virtual Machines (Microsoft.Compute/virtualMachines) Virtual Networks (Microsoft.Network/virtualNetworks) IP Addresses (Microsoft.Network/publicIPAddresses) Network Interfaces (Microsoft.Network/networkInterfaces) Storage Accounts (Microsoft.Storage/storageAccounts)  In addition, every VM you create will add a SecureString parameter to the ARM template, whose name follows the pattern password-for-[virtual machine name].\nBuilder Keywords    Keyword Purpose     name Sets the name of the VM.   diagnostics_support Turns on diagnostics support using an automatically created created storage account.   diagnostics_support_external Turns on diagnostics support using an existing storage account.   vm_size Sets the size of the VM.   username Sets the admin username of the VM (note: the password is supplied as a securestring parameter to the generated ARM template).   operating_system Sets the operating system of the VM. A set of samples is provided in the CommonImages module.   os_disk Sets the size and type of the OS disk for the VM.   add_disk Adds a data disk to the VM with a specific size and type.   add_ssd_disk Adds a SSD data disk to the VM with a specific size.   add_slow_disk Adds a conventional (non-SSD) data disk to the VM with a specific size.   domain_name_prefix Sets the prefix for the domain name of the VM.   address_prefix Sets the IP address prefix of the VM.   subnet_prefix Sets the subnet prefix of the VM.    Configuration Members    Member Purpose     NicName Provides the resource name of the Network Interface Card (NIC)   VnetName Provides the resource name of the Virtual Network (VNet)   SubnetName Provides the resource name of the subnet   IpName Provides the resource name of the IP Address   Hostname Returns an ARM expression to retrieve the fully-qualified domain name from the virtual machine\u0026rsquo;s DNS settings.\u0026rdquo;    Example open Farmer open Farmer.Builders let myVm = vm { name \u0026#34;myFarmerVm\u0026#34; username \u0026#34;yourUsername\u0026#34; vm_size Vm.Standard_A2 operating_system Vm.WindowsServer_2012Datacenter os_disk 128 Vm.StandardSSD_LRS add_ssd_disk 128 add_slow_disk 512 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/web-app/","title":"Web App","tags":[],"description":"","content":"Overview The Web App builder is used to create Azure App Service accounts. It abstracts the Service Plan into the same component, and will also create and configure a linked App Insights resource. If you wish to create a website that connects to an existing service plan, use the link_to_service_plan keyword and provide the resource name of the service plan to connect to.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Site Extension (siteextensions)  Web App Builder Keywords    Applies To Keyword Purpose     Web App name Sets the name of the web app.   Web App link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   Web App app_insights_auto_name Sets the name of the automatically-created app insights instance.   Web App app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   Web App link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   Web App run_from_package Sets the web app to use \u0026ldquo;run from package\u0026rdquo; deployment capabilities.   Web App website_node_default_version Sets the node version of the web app.   Web App setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   Web App settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   Web App https_only Disables http for this webapp so that only HTTPS is used.   Web App depends_on Sets a dependency for the web app.   Web App docker_image Sets the docker image to be pulled down from Docker Hub, and the command to execute as a second argument. Automatically sets the OS to Linux.   Web App docker_ci Turns on continuous integration of the web app from the Docker source repository using a webhook.   Web App docker_use_azure_registry Uses the supplied Azure Container Registry name as the source of the Docker image, instead of Docker Hub. You do not need to specify the full url, but just the name of the registry itself.   Service Plan service_plan_name Sets the name of the service plan. If not set, uses the name of the web app postfixed with \u0026ldquo;-plan\u0026rdquo;.   Service Plan always_on Sets \u0026ldquo;Always On\u0026rdquo; flag.   Service Plan runtime_stack Sets the runtime stack.   Service Plan operating_system Sets the operating system. If Linux, App Insights configuration settings will be omitted as they are not supported by Azure App Service.   Service Plan sku Sets the sku of the service plan.   Service Plan worker_size Sets the size of the service plan worker.   Service Plan number_of_workers Sets the number of instances on the service plan.     Farmer also comes with a dedicated Service Plan builder that contains all of the above keywords that apply to a Service Plan.\nUse this builder if you wish to have an explicit and clear separation between your web app and service plan. Otherwise, it is recommended to use the service plan keywords that exist directly in the web app builder, and let Farmer handle the connections between them.\n Post-deployment Builder Keywords The Web App builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the App Service once the ARM deployment is complete.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this web app.   ServicePlan Gets the Resource Name of the service plan for this web app.   AppInsights Gets the Resource Name of the service plan for the AI resource linked to this web app.    Example open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku WebApp.B1 always_on app_insights_off worker_size Medium number_of_workers 3 run_from_package } "},{"uri":"https://compositionalit.github.io/farmer/arm-vs-farmer/","title":"Farmer and ARM","tags":[],"description":"","content":"    Farmer ARM Template     Core ARM features     Repeatable deployments? Yes, Farmer runs on top of ARM Yes   ARM deployment mechanisms? All, plus easy-to-use F# deployment All   Variables support? Yes, native support in F# Yes   Parameters support? Yes, native support in F# or secure parameters Yes   Supported resources? 30+ popular resources, with more being added all the time All   Declarative model support? Yes Yes   Support for all ARM tools? Yes, Farmer runs on top of ARM Yes   Authoring     Easy to author? Yes No   Easy to read? Yes No   Documented? Yes, website and discoverable intellisense Limited, documented but often out-of-date   Editor support? Yes, any F# editor including VS Code, VS and Rider Limited, only VS Code has any support   Safety     Type-safe? Yes, full support from the F# compiler and type system Limited through VS Code extension and LSP   Validation support? Edit-time, run-time, deploy-time Deploy-time and limited edit-time   Flexibility     Link resources easily? Yes Not easily complex path expressions must be known   Compose resources together? Yes Not easily   Create multiple resources simultaneously? Yes No, each resource must be defined separately   Create resources in several ways? Yes, builders, records, functions or classes No, must use JSON   Full programming language? Yes, F# is a simple yet powerful programming language No, JSON with limited functions   Imperative model? Yes, F# supports imperative programming No, you must program in a declarative style   Interop and extensibility     Add your own ARM resources? Yes, plug-in model to add new ARM resources N/A   Create your own combinations of resources? Yes No, each resource must be defined separately   Use external libraries? Yes, use any NuGet packages during authoring and full .NET Core No, fixed set of functions   Use in .NET applications? Yes, Farmer is a .NET Core library and can be used in-proc No, JSON files    "},{"uri":"https://compositionalit.github.io/farmer/","title":"Farmer","tags":[],"description":"","content":"  Making repeatable Azure deployments easy! Farmer is a DSL for rapidly generating non-complex ARM templates in a type-safe manner.\nMain Features  Create ARM templates quickly and easily through a simple, strongly-typed and pragmatic DSL. Completely backwards compatible with ARM templates. Farmer generates standard ARM templates so you can continue to use existing deployment processes. Runs on .NET Core. Safely create dependencies between resources. Uses static typing to give confidence that your templates will work first time. Easily access common properties of resources. No more fighting to concatenate cryptic strings! Extensible API. Add new helpers and members as needed. Open source and free. Farmer is free to use. We welcome contributions to the project!  Farmer uses a simple DSL to declare resources and comes with helper functions to perform common tasks. Farmer templates are around 5-8 times smaller than ARM templates, meaning they are quicker and easier to author, understand and maintain.\nCreating a web application with a configured application insights and a linked storage account Farmer Templates These 23 lines of simple, readable and type-safe code are translated into 142 lines of JSON ARM template!\n// Create a storage account with a container let myStorageAccount = storageAccount { name \u0026#34;myTestStorage\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } // Create a web app with application insights that\u0026#39;s connected to the storage account. let myWebApp = webApp { name \u0026#34;myTestWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key always_on depends_on myStorageAccount.Name } // Create an ARM template let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } // Deploy it to Azure! deployment |\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34; Want to try it out? Follow our quickstart guide now! "},{"uri":"https://compositionalit.github.io/farmer/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://compositionalit.github.io/farmer/tags/","title":"Tags","tags":[],"description":"","content":""}]